<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML Chess Game</title>
    <!-- CDN Links with CORRECTED Integrity Hashes -->
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css"
          integrity="sha384-q94+BZtLrkL1/ohfjR8c6L+A6qzNH9R2hBLwyoAfu3i/WCvQjzL2RQJ3uNHDISdU"
          crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"
            integrity="sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK"
            crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"
            integrity="sha384-8Vi8VHwn3vjQ9eUHUxex3JSN/NFqUg3QbPyX8kWyb93+8AC/pPWTzj+nHtbC5bxD"
            crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"
            integrity="sha512-xRllwz2gdZciIB+AkEbeq+gVhX8VB8XsfqeFbUh+SzHlN96dEduwtTuVuc2u9EROlmW9+yhRlxjif66ORpsgVA=="
            crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <style>
        /* Basic Reset & Body Styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Arial', sans-serif; /* Simple, clear font */
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
            color: #333;
        }

        /* Main Container */
        .container {
            background-color: #ffffff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            max-width: 95%;
            width: 500px; /* Default width */
            text-align: center;
            overflow: hidden; /* Prevent content breaking layout during transitions */
        }

        /* Mode Selection Screen */
        #mode-selection {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px; /* Spacing between elements */
            transition: opacity 0.3s ease-out;
        }

        #mode-selection h2 {
            color: #4a4a4a;
            margin-bottom: 10px;
        }

        /* Game Screen */
        #game-screen {
            display: none; /* Initially hidden */
            flex-direction: column;
            align-items: center;
            gap: 15px;
            transition: opacity 0.3s ease-in;
        }

        /* Buttons (General) */
        button {
            padding: 12px 25px;
            font-size: 1.1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            color: white;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
            min-width: 150px; /* Ensure buttons have minimum width */
        }

        button:hover {
            opacity: 0.9;
        }
        button:active {
            transform: scale(0.98);
        }

        /* Specific Button Colors */
        .btn-beginner { background-color: #6ab04c; } /* Green */
        .btn-intermediate { background-color: #f0ad4e; } /* Orange */
        .btn-advanced { background-color: #d9534f; } /* Red */
        .btn-action { background-color: #5bc0de; } /* Blue */
        .btn-back { background-color: #777; } /* Grey */

        /* Top Controls (Back/Restart/Status) */
        .game-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            gap: 10px;
            margin-bottom: 10px;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
        }

        .control-buttons button {
            padding: 8px 15px;
            font-size: 0.9em;
            min-width: auto; /* Override general button min-width */
        }


        /* Status Display */
        #status {
            font-size: 1.1em;
            font-weight: bold;
            padding: 8px 12px;
            background-color: #e9ecef;
            border-radius: 5px;
            min-height: 40px; /* Ensure consistent height to avoid layout shifts */
            line-height: 24px; /* Vertically align text better */
            transition: background-color 0.3s ease, color 0.3s ease;
            flex-grow: 1; /* Allow status to take available space */
            text-align: center; /* Center text within status */
            margin: 5px 0; /* Add some margin when stacked */
        }

        .status-highlight {
            background-color: #ffc107; /* Yellow for check/game over */
            color: #333;
        }

        /* Chessboard */
        #board {
            width: 100%; /* Make board responsive */
            max-width: 450px; /* Max size */
            margin: 10px auto; /* Center the board, add margin */
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border-radius: 4px; /* Slight rounding */
            overflow: hidden; /* Ensure pieces don't overflow */
        }

        /* Hover effects for squares (uses classes added by chessboard.js) */
        .highlight-white {
            box-shadow: inset 0 0 3px 3px rgba(255, 255, 0, 0.6); /* Yellow glow */
        }
        .highlight-black {
             box-shadow: inset 0 0 3px 3px rgba(255, 255, 0, 0.6);
        }


        /* Utility Classes for Screen Transitions */
        .hidden {
            display: none;
            opacity: 0;
            /* visibility: hidden; Avoids taking up space */
        }
        .visible {
             display: flex; /* Use flex for screen containers */
             flex-direction: column; /* Ensure content flows vertically */
             align-items: center; /* Center content */
             opacity: 1;
             /* visibility: visible; */
         }

        /* Responsive Adjustments */
        @media (max-width: 600px) {
            .container {
                width: 95%;
                padding: 15px;
            }
            #board {
                max-width: 100%; /* Allow board to fill container width */
            }
            button {
                padding: 10px 20px;
                font-size: 1em;
            }
             .game-controls {
                flex-direction: column; /* Stack controls vertically */
                 gap: 15px;
            }
            .control-buttons {
                width: 100%;
                justify-content: space-around; /* Space out buttons */
            }
            #status {
                width: 100%;
                text-align: center;
                order: -1; /* Move status above buttons on small screens */
            }
             .control-buttons button {
                flex-grow: 1; /* Make control buttons take equal width */
            }
        }

    </style>
</head>
<body>
    <div class="container">
        <!-- Mode Selection Screen -->
        <div id="mode-selection" class="visible">
            <h2>Select Difficulty</h2>
            <button id="btn-beginner" class="btn-beginner">Beginner</button>
            <button id="btn-intermediate" class="btn-intermediate">Intermediate</button>
            <button id="btn-advanced" class="btn-advanced">Advanced</button>
            <!-- Simple back using browser history - less ideal, but okay for simple demo -->
            <!-- <a href="javascript:history.back()" style="text-decoration: none;">
               <button class="btn-back">Back (Browser)</button>
            </a> -->
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="hidden">
            <div class="game-controls">
                 <div id="status">Select difficulty to start</div> <!-- Status moved here for flex order -->
                 <div class="control-buttons">
                     <button id="btn-back-menu" class="btn-back">Back to Menu</button>
                     <button id="btn-restart" class="btn-action">Restart Game</button>
                 </div>
            </div>
            <div id="board"></div>
            <!-- Optional: Mute button -->
            <!-- <button id="btn-mute">Mute Music</button> -->
        </div>
    </div>

    <!-- Audio Elements -->
    <!-- NOTE: Replace '#' with actual paths to your sound files or use Base64 URIs -->
    <audio id="move-sound" src="#" preload="auto"></audio>
    <audio id="capture-sound" src="#" preload="auto"></audio>
    <audio id="check-sound" src="#" preload="auto"></audio>
    <audio id="game-over-sound" src="#" preload="auto"></audio>
    <!-- <audio id="ambient-music" src="#" preload="auto" loop></audio> -->


    <script>
        // Ensure script runs after DOM is fully loaded
        $(document).ready(function () {
            console.log("Document Ready - Initializing...");

            // --- Global Variables ---
            var board = null; // Chessboard.js instance
            var game = null; // Chess.js instance - Initialize in startGame
            var selectedDifficulty = null;
            var playerColor = 'w'; // Player is always white

            // --- DOM Elements ---
            var $modeSelection = $('#mode-selection');
            var $gameScreen = $('#game-screen');
            var $status = $('#status'); // Cache the status element
            var $boardContainer = $('#board'); // The div container
            var $btnBeginner = $('#btn-beginner');
            var $btnIntermediate = $('#btn-intermediate');
            var $btnAdvanced = $('#btn-advanced');
            var $btnBackMenu = $('#btn-back-menu');
            var $btnRestart = $('#btn-restart');

            // --- Audio Elements ---
            var moveSound = document.getElementById('move-sound');
            var captureSound = document.getElementById('capture-sound');
            var checkSound = document.getElementById('check-sound');
            var gameOverSound = document.getElementById('game-over-sound');

            // --- Constants ---
            var AI_TIMEOUT = 250; // Slightly shorter delay for AI move

            // --- Sound Playback Helper ---
            function playSound(soundElement) {
                if (soundElement && typeof soundElement.play === 'function') {
                    soundElement.currentTime = 0; // Rewind to start
                    soundElement.play().catch(e => console.warn("Audio play prevented (user interaction might be needed):", e));
                } else {
                    // console.log("Debug: Sound element not found or not playable", soundElement);
                }
            }

            // --- Game Logic Functions ---

            function updateStatus() {
                if (!game) {
                    console.warn("updateStatus called before game was initialized.");
                    $status.text("Initializing...");
                    $status.removeClass('status-highlight'); // Ensure no highlight initially
                    return;
                }
                var statusText = '';
                var moveColor = (game.turn() === 'w' ? 'White' : 'Black');

                // Reset highlight class initially
                 $status.removeClass('status-highlight');

                if (game.in_checkmate()) {
                    statusText = 'Game Over: ' + moveColor + ' is in checkmate.';
                    playSound(gameOverSound);
                    $status.addClass('status-highlight');
                }
                else if (game.in_draw()) {
                    statusText = 'Game Over: Draw';
                    if (game.in_stalemate()) { statusText += ' (Stalemate)'; }
                    else if (game.in_threefold_repetition()) { statusText += ' (Threefold Repetition)'; }
                    else if (game.insufficient_material()) { statusText += ' (Insufficient Material)'; }
                    else { statusText += ' (50-move rule)';}
                    playSound(gameOverSound);
                    $status.addClass('status-highlight');
                }
                else { // Game ongoing
                    statusText = moveColor + "'s turn";
                    if (game.in_check()) {
                        statusText += ' - Check!';
                        playSound(checkSound);
                        $status.addClass('status-highlight'); // Highlight for check too
                    }
                }
                // console.log("Updating Status:", statusText);
                $status.text(statusText); // Update the cached element
            }

            function onDragStart(source, piece, position, orientation) {
                // Allow drag only if game is active, it's player's turn, and piece belongs to player
                if (!game || game.game_over() || game.turn() !== playerColor ||
                    (playerColor === 'w' && piece.search(/^b/) !== -1) ||
                    (playerColor === 'b' && piece.search(/^w/) !== -1)) {
                    return false;
                }
                // console.log("Drag Start:", source, piece);
                return true; // Allow drag
            }

            function onDrop(source, target) {
                // console.log("Drop:", source, "->", target);
                if (!game) return 'snapback';

                var move = null;
                try {
                    // Attempt the move
                    move = game.move({
                        from: source,
                        to: target,
                        promotion: 'q' // Always promote to queen for simplicity
                    });
                } catch (e) {
                    console.error("Error making move in chess.js:", e);
                    return 'snapback'; // Prevent board update on error
                }

                // Illegal move - chess.js returns null
                if (move === null) {
                    // console.log("Illegal move attempted");
                    return 'snapback';
                }

                // console.log("Player Move successful:", move.san);

                // Play sound
                if (move.flags.includes('c') || move.flags.includes('e')) { // Capture or En Passant
                    playSound(captureSound);
                } else {
                    playSound(moveSound);
                }

                updateStatus(); // Update status immediately after player move

                // Schedule AI move if the game isn't over
                if (!game.game_over()) {
                    // console.log("Scheduling AI move...");
                    // Disable board temporarily? Could add a class to the board container
                    // $boardContainer.css('pointer-events', 'none'); // Prevent user input during AI calculation
                    window.setTimeout(makeAiMove, AI_TIMEOUT);
                } else {
                    // console.log("Game is over after player move.");
                }
            }

            // Called after the piece animation completes
            function onSnapEnd() {
                if (board && game) {
                    // Ensure the board reflects the chess.js state, especially for special moves
                    // console.log("Snap End - Syncing board position to FEN:", game.fen());
                    board.position(game.fen());
                } else {
                    console.warn("Snap End called but board or game missing.");
                }
            }

            // --- AI Move Logic ---

            function makeAiMove() {
                // console.log("makeAiMove called");
                if (!game || game.game_over()) {
                    console.log("AI move skipped: Game over or not initialized.");
                    // $boardContainer.css('pointer-events', 'auto'); // Re-enable input if skipped
                    return;
                }
                if (game.turn() === playerColor) {
                    console.warn("AI move function called, but it's player's turn?");
                    // $boardContainer.css('pointer-events', 'auto'); // Re-enable input
                    return;
                }

                var move = null;
                // console.log("Calculating AI move for difficulty:", selectedDifficulty);
                var startTime = performance.now();

                try {
                    switch (selectedDifficulty) {
                        case 'beginner':
                            move = getRandomMove();
                            break;
                        case 'intermediate':
                             // AI ('b') is the maximizing player relative to its evaluation function
                             // The first call starts the search for AI's best move.
                            move = calculateBestMoveMinimax(2, game, true); // Depth 2, AI is maximizing
                            break;
                        case 'advanced':
                             // AI ('b') is maximizing player. Alpha starts at -Inf, Beta at +Inf.
                            move = calculateBestMoveAlphaBeta(3, game, -Infinity, Infinity, true); // Depth 3, AI is maximizing
                            break;
                        default:
                            console.error("Invalid difficulty for AI:", selectedDifficulty);
                            // $boardContainer.css('pointer-events', 'auto'); // Re-enable input
                            return;
                    }
                } catch(e) {
                    console.error("Error during AI calculation:", e);
                    move = getRandomMove(); // Fallback to random move
                }

                var endTime = performance.now();
                console.log(`AI (${selectedDifficulty}) calculation took ${Math.round(endTime - startTime)} ms`);

                // Make the move on the board if one was found
                if (move) {
                    // console.log("AI Chose move:", move.san ? move.san : move); // Use SAN if available
                    var chessJsMove = null;
                    try {
                        chessJsMove = game.move(move); // Apply the chosen move
                    } catch(e) {
                        console.error("Error making AI move in chess.js:", e);
                        updateStatus();
                        // $boardContainer.css('pointer-events', 'auto'); // Re-enable input
                        return;
                    }

                    // Play sound for AI move
                    if (chessJsMove && (chessJsMove.flags.includes('c') || chessJsMove.flags.includes('e'))) {
                        playSound(captureSound);
                    } else if (chessJsMove) {
                        playSound(moveSound);
                    }

                    // Update board UI and game status
                    if (board) {
                        // console.log("AI Move - Updating board position to FEN:", game.fen());
                        board.position(game.fen());
                    }
                    updateStatus();

                    if (game.game_over()) {
                        // console.log("Game is over after AI move.");
                    } else {
                        // console.log("AI move complete, player's turn.");
                    }
                } else {
                    console.error("AI failed to find a valid move! (Difficulty: " + selectedDifficulty + ")");
                    updateStatus(); // Show current status even if AI fails
                }

                // Re-enable user input after AI move is processed
                // $boardContainer.css('pointer-events', 'auto');
            }

            // --- AI Algorithms ---

            // Beginner: Random Move
            function getRandomMove() {
                if (!game) return null;
                var possibleMoves = game.moves({ verbose: true });
                if (possibleMoves.length === 0) return null;
                var randomIndex = Math.floor(Math.random() * possibleMoves.length);
                // console.log("AI Beginner: Chose random move", possibleMoves[randomIndex].san);
                return possibleMoves[randomIndex];
            }

            // Simple Evaluation Function (Material Count - From perspective of 'color')
            function evaluateBoard(boardState, color) {
                var pieceValue = { 'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9, 'k': 0 };
                var score = 0;
                // Checkmate/Stalemate bonus/penalty (basic)
                 if (game.in_checkmate()) {
                     // If the current turn player (the one checkmated) is NOT the color we're evaluating for, it's a win
                     score += (game.turn() !== color ? 9999 : -9999);
                 } else if (game.in_stalemate() || game.in_draw()) {
                     score = 0; // Draw is neutral
                 } else {
                     // Material count if game is ongoing
                     boardState.forEach(function(row) {
                         row.forEach(function(piece) {
                             if (piece) {
                                 var value = pieceValue[piece.type];
                                 score += (piece.color === color ? value : -value);
                             }
                         });
                     });
                 }
                 // Add slight randomness to avoid always picking the same move among equals?
                 // score += (Math.random() - 0.5) * 0.1;
                return score;
            }

            // Intermediate: Minimax - Find best move for maximizing player
             function calculateBestMoveMinimax(depth, currentGame, isMaximizingPlayer) {
                 var possibleMoves = currentGame.moves({ verbose: true });
                 if (possibleMoves.length === 0) return null;

                 var bestMoveValue = -Infinity; // Start assuming worst score for the maximizing player
                 var bestMoveFound = null;

                 possibleMoves.sort(() => 0.5 - Math.random()); // Shuffle for variety

                 for (var i = 0; i < possibleMoves.length; i++) {
                     var currentMove = possibleMoves[i];
                     currentGame.move(currentMove);
                     // Evaluate this move by looking ahead: the opponent (minimizing) will play next
                     var value = minimax(depth - 1, currentGame, !isMaximizingPlayer); // Pass opponent's role
                     currentGame.undo();

                     // console.log("Minimax Root: Move", currentMove.san, "evaluated to", value);
                     if (value >= bestMoveValue) {
                         bestMoveValue = value;
                         bestMoveFound = currentMove;
                     }
                 }
                 // console.log("Minimax best move:", bestMoveFound?.san, "Value:", bestMoveValue);
                 return bestMoveFound || getRandomMove(); // Fallback
             }

             function minimax(depth, currentGame, isMaximizingPlayer) {
                 if (depth === 0 || currentGame.game_over()) {
                     // Evaluate board from the perspective of the AI ('b') which is the initial Maximizing player
                     return evaluateBoard(currentGame.board(), 'b');
                 }

                 var possibleMoves = currentGame.moves();
                 if (possibleMoves.length === 0) {
                     return evaluateBoard(currentGame.board(), 'b');
                 }

                 var bestValue;
                 if (isMaximizingPlayer) { // AI's turn in simulation
                     bestValue = -Infinity;
                     for (var i = 0; i < possibleMoves.length; i++) {
                         currentGame.move(possibleMoves[i]);
                         bestValue = Math.max(bestValue, minimax(depth - 1, currentGame, false)); // Opponent minimizes next
                         currentGame.undo();
                     }
                 } else { // Player's turn in simulation
                     bestValue = Infinity;
                     for (var i = 0; i < possibleMoves.length; i++) {
                         currentGame.move(possibleMoves[i]);
                         bestValue = Math.min(bestValue, minimax(depth - 1, currentGame, true)); // AI maximizes next
                         currentGame.undo();
                     }
                 }
                 return bestValue;
             }

            // Advanced: Alpha-Beta - Find best move for maximizing player
             function calculateBestMoveAlphaBeta(depth, currentGame, alpha, beta, isMaximizingPlayer) {
                 var possibleMoves = currentGame.moves({ verbose: true });
                 if (possibleMoves.length === 0) return null;

                 var bestMoveValue = -Infinity; // Maximizing player starts low
                 var bestMoveFound = null;

                 possibleMoves.sort(() => 0.5 - Math.random()); // Shuffle

                 for (var i = 0; i < possibleMoves.length; i++) {
                    var currentMove = possibleMoves[i];
                    currentGame.move(currentMove);
                    // Start recursive call for the opponent (minimizing player)
                    var value = alphaBeta(depth - 1, currentGame, alpha, beta, !isMaximizingPlayer); // Pass opponent's role
                    currentGame.undo();

                    // console.log("AlphaBeta Root: Move", currentMove.san, "evaluated to", value);
                    if (value > bestMoveValue) { // Found a better move for maximizing player
                        bestMoveValue = value;
                        bestMoveFound = currentMove;
                    }
                    alpha = Math.max(alpha, bestMoveValue); // Update alpha (best score maximizing player can guarantee)

                    // Root pruning check (though real pruning happens deeper)
                    // if (beta <= alpha) { break; }
                 }
                 // console.log("AlphaBeta best move:", bestMoveFound?.san, "Value:", bestMoveValue, "Alpha:", alpha, "Beta:", beta);
                 return bestMoveFound || getRandomMove(); // Fallback
             }

            function alphaBeta(depth, currentGame, alpha, beta, isMaximizingPlayer) {
                if (depth === 0 || currentGame.game_over()) {
                    // Evaluate board from AI's perspective ('b')
                    return evaluateBoard(currentGame.board(), 'b');
                }

                var possibleMoves = currentGame.moves();
                 if (possibleMoves.length === 0) {
                      return evaluateBoard(currentGame.board(), 'b');
                 }

                 // Optional: Move Ordering Heuristic (e.g., captures first) could improve pruning significantly
                 // possibleMoves.sort(...)

                var bestValue;
                if (isMaximizingPlayer) { // AI's turn ('b')
                    bestValue = -Infinity;
                    for (var i = 0; i < possibleMoves.length; i++) {
                        currentGame.move(possibleMoves[i]);
                        bestValue = Math.max(bestValue, alphaBeta(depth - 1, currentGame, alpha, beta, false)); // Opponent minimizes next
                        currentGame.undo();
                        alpha = Math.max(alpha, bestValue); // Update best score AI can force
                        if (beta <= alpha) {
                            // console.log("Pruning (max): alpha", alpha, "beta", beta, "depth", depth);
                            break; // Beta cutoff
                        }
                    }
                } else { // Player's turn ('w')
                    bestValue = Infinity;
                    for (var i = 0; i < possibleMoves.length; i++) {
                        currentGame.move(possibleMoves[i]);
                        bestValue = Math.min(bestValue, alphaBeta(depth - 1, currentGame, alpha, beta, true)); // AI maximizes next
                        currentGame.undo();
                        beta = Math.min(beta, bestValue); // Update best score Player can force (worst for AI)
                        if (beta <= alpha) {
                            // console.log("Pruning (min): alpha", alpha, "beta", beta, "depth", depth);
                            break; // Alpha cutoff
                        }
                    }
                }
                return bestValue;
            }

            // --- UI Interaction ---

            function startGame(difficulty) {
                console.log("startGame called with difficulty:", difficulty);

                // Verify Libraries are loaded (Defensive check)
                if (typeof Chess === "undefined" || typeof Chessboard === "undefined" || typeof $ === "undefined") {
                    console.error("ERROR: Required libraries (jQuery, Chess.js, Chessboard.js) not loaded correctly. Check console for integrity/network errors.");
                    $status.text("ERROR: Libraries failed to load!");
                    alert("Error: Game libraries failed to load. Please check your internet connection or browser console (F12) for errors.");
                    return;
                }

                selectedDifficulty = difficulty;
                try {
                    // console.log("Initializing Chess object...");
                    game = new Chess(); // Reset game state
                    // console.log("Chess object initialized.");
                } catch(e) {
                    console.error("Failed to initialize Chess object:", e);
                    $status.text("ERROR: Failed to initialize game logic.");
                    return;
                }

                // Configure chessboard.js
                var boardConfig = {
                    draggable: true,
                    position: 'start',
                    onDragStart: onDragStart,
                    onDrop: onDrop,
                    onSnapEnd: onSnapEnd,
                    sparePieces: false,
                    dropOffBoard: 'snapback',
                    pieceTheme: 'https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/img/chesspieces/wikipedia/{piece}.png',
                     // Add hover highlights (requires CSS)
                    highlightSelector: '.highlight-white, .highlight-black',
                    // hoverClass: 'highlight-hover', // If you add specific hover CSS
                };

                // Initialize or re-initialize the board
                try {
                    if (board) {
                        // console.log("Destroying existing board instance...");
                        board.destroy();
                        board = null;
                    }
                    // console.log("Initializing Chessboard object with container ID 'board'...");

                    // Ensure the game screen is visible BEFORE initializing board
                    $modeSelection.removeClass('visible').addClass('hidden');
                    $gameScreen.removeClass('hidden').addClass('visible');

                    // IMPORTANT: Ensure the #board div is present and visible in the DOM here
                    board = Chessboard('board', boardConfig); // Initialize

                    // Make board responsive on resize (ensure handler is unique)
                    $(window).off('resize.chessboard').on('resize.chessboard', () => { if(board) board.resize(); });
                    // console.log("Chessboard initialized successfully.");

                } catch (e) {
                    console.error("Error initializing chessboard:", e);
                    $status.text("ERROR: Failed to create board UI.");
                    // Attempt to revert UI if board fails
                    $gameScreen.removeClass('visible').addClass('hidden');
                    $modeSelection.removeClass('hidden').addClass('visible');
                    return;
                }

                // Set initial game status
                updateStatus();
                console.log("startGame finished successfully for difficulty:", difficulty);
            }

            function goBackToMenu() {
                console.log("goBackToMenu called");
                if (board) {
                    // console.log("Destroying board instance for menu.");
                    board.destroy();
                    board = null;
                }
                game = null; // Reset logic object
                selectedDifficulty = null;

                // Switch screens
                $gameScreen.removeClass('visible').addClass('hidden');
                $modeSelection.removeClass('hidden').addClass('visible');
                $status.text("Select difficulty to start").removeClass('status-highlight');
                console.log("Returned to menu.");
            }

            // --- Event Listeners ---
            // console.log("Attaching event listeners...");

            $btnBeginner.on('click', function () { /* console.log("Beginner Clicked"); */ startGame('beginner'); });
            $btnIntermediate.on('click', function () { /* console.log("Intermediate Clicked"); */ startGame('intermediate'); });
            $btnAdvanced.on('click', function () { /* console.log("Advanced Clicked"); */ startGame('advanced'); });

            $btnBackMenu.on('click', goBackToMenu);

            $btnRestart.on('click', function () {
                // console.log("Restart Clicked");
                if (selectedDifficulty && game) { // Restart only if a game is active
                    // console.log("Restarting game with difficulty:", selectedDifficulty);
                    startGame(selectedDifficulty);
                } else {
                    console.warn("Restart clicked but no game active.");
                    // Optionally go back to menu if restart is invalid
                    // goBackToMenu();
                }
            });
            // console.log("Event listeners attached.");

            // --- Initial Page Setup ---
            // console.log("Running initial visibility setup...");
            // Ensure only mode selection is visible on load
            $gameScreen.removeClass('visible').addClass('hidden');
            $modeSelection.removeClass('hidden').addClass('visible');
            $status.text("Select difficulty to start").removeClass('status-highlight'); // Set initial text

        }); // End document ready
    </script>
</body>
</html>